<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Top Hat</title>
    <style>
        canvas {
            display: block;
            margin: 10px auto;
            width: 80%;
            height: 600px;
        }
    </style>

    <script src="./js/three.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/SceneUtils.js"></script>
    <script src="./js/dat.gui.js"></script>

</head>

<body>
    <script id="beaniecode">
        // parameters that specify the geometrical structure of the top hat
        var scene = new THREE.Scene();
        var renderer = new THREE.WebGLRenderer();

        // add perpective camera
        var camera = new THREE.PerspectiveCamera(70, 1, 1, 1000);
        camera.position.set(0, 0, 1000);
        camera.up.set(10, 10, 10);
      //  camera.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add(camera);

        function render(){
            renderer.render(scene, camera);
        }

      // add two directional light sources

    //   var light1 = new THREE.DirectionalLight(0xffffff, 2);
    //   light1.position.set(1, 1, 1);
    //   scene.add(light1);

    //   var light2 = new THREE.DirectionalLight(0xffffff);
    //   light2.position.set(-1, -1, -1);
    //   scene.add(light2);

    //   // create box geometry to use for all the blocks
    //   var params = {
    //         headRadius: 3,
    //         hatHeight: 3, 
    //         bottomHatRadius: 2.7,
    //         hatRadius: 2,
    //         hatRotation: 0,
    //         zPlaneRotation: 0,
    //         xPlaneRotation:0,
    //         hatSeg: 1,
    //         yHeadPosition: 9
    //     };

    //     // colors and materials for the top hat
    //     var headMaterial = new THREE.MeshBasicMaterial({ color: 0xD08050 });
    //     var blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
    //     var goldMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700});

    //     function createHat(texture){
    //         // create and return a Mesh for the hat
    //         var height = params.hatHeight;
    //         var radius = params.hatRadius;
    //         var hatGeometry = new THREE.CylinderGeometry(radius, radius, height, 40, params.hatSeg);
    //         var silkMaterial = new THREE.MeshBasicMaterial({ color: "0xFFD700", map: texture});
    //         var hatMesh = new THREE.Mesh(hatGeometry, silkMaterial);
    //         return hatMesh;
    //     }
    //     function createBottomHat(texture){
    //         // create and return a Mesh for the bottom of the hat
    //         var radius = params.bottomHatRadius;
    //         var hatGeometry = new THREE.CylinderGeometry(radius, radius, 0.45, 40, params.hatSeg);
    //         var silkMaterial = new THREE.MeshBasicMaterial({ color: "0xFFD700", map: texture});
    //         var hatMesh = new THREE.Mesh(hatGeometry, silkMaterial);
    //         return hatMesh;
    //     }

    //     function createDesignHat(texture){
    //         // create and return a Mesh for the design of the hat
    //         var radius = params.hatRadius;
    //         var hatGeometry = new THREE.CylinderGeometry(radius + 0.1, radius + 0.1, 0.7, 40, params.hatSeg);
    //         var silkMaterial = new THREE.MeshBasicMaterial({ color: "0xFFD700", map: texture});
    //         var hatMesh = new THREE.Mesh(hatGeometry, silkMaterial);
    //         return hatMesh;
    //     }

    //     function addHat(textures){
    //         // adds all components of hat together
    //         var hatframe = new THREE.Object3D();
    //         var hat = createHat(textures[0]);
    //         var bottomHat = createBottomHat(textures[0]);
    //         var design = createDesignHat(textures[1]);
    //         hatframe.add(hat);
    //         hatframe.add(bottomHat);
    //         hatframe.add(design)
    //         // calculate position for the center of the head
    //         hat.position.y = 3.8;
    //         hat.position.x = 0;
    //         bottomHat.position.y = 2.3;
    //         bottomHat.position.x = 0;
    //         design.position.y = 2.7;
    //         design.position.x = 0;
    //         hat.rotation.y = params.hatRotation;
    //         bottomHat.rotation.y = params.hatRotation;
    //         scene.add(hatframe);
    //         //render();
    //     }

        // var tl = new THREE.TextureLoader();
        // var texture1 = tl.load("silk.jpeg", render);
        // var texture2 = tl.load("yellowsilk.jpeg", render);
        // var textures = [texture1, texture2];
        //addHat(textures);

        const geometry = new THREE.SphereGeometry( 15, 32, 16 ); 
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
const sphere = new THREE.Mesh( geometry, material ); scene.add( sphere );
        //render();


    //   TW.loadTextures(["silk.jpeg", "yellowsilk.jpeg"],
    //         function (texture) {
    //             addHat(texture);
    //         } );
      // setup camera for the scene, looking down the -Z axis

      // add event listener to handle mouse clicks

    //   document.addEventListener('click', onClick, false);

    //   // raycasting is used to determine which objects in the 3D space map to the mouse click location

    //   var raycaster = new THREE.Raycaster();
    //   var mouse = new THREE.Vector2();

    //   // global variable assigned to canvas element

    //   var c1 = renderer.domElement;

    //   // pressing the shift key while clicking the mouse causes a block in the vicinity to be
    //   // removed from the scene

    //   function onClick(event) {
    //      if (!event.shiftKey) return;      // need to press the shift key with mouse click
    //      if (event.target == c1) {
    //         // use canvas offset to determine mouse coordinates in canvas coordinate frame
    //         var rect = event.target.getBoundingClientRect();
    //         var canvasx = event.clientX - rect.left;
    //         var canvasy = event.clientY - rect.top;
    //      } else {
    //         return;
    //      }
    //      // get mouse coordinates in the range from -1 to +1 (canvas is 600 x 600 pixels)
    //      mouse.x = (canvasx / 600) * 2 - 1;
    //      mouse.y = -(canvasy / 600) * 2 + 1;
    //      // setup raycaster using mouse position and camera
    //      raycaster.setFromCamera(mouse, camera);
    //      // get array of objects projecting to this mouse position
    //      var intersects = raycaster.intersectObjects(scene.children);
    //      // remove first object in the array, which is closest in depth to the camera
    //      if (intersects.length > 0) {
    //         scene.remove(intersects[0].object);
    //         render();
    //      }
    //   }

     // render();

    </script>
    <!-- <cavas width="2156" height="600" style="width: 2156px; height: 600px;"></canvas> -->

</body>

</html>